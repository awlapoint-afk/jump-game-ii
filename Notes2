Algorithm:

1. Keep `nums[0] = 0` (0 jumps to reach starting position)
2. For each position `i` from 1 to n, find the minimum
   of `nums[j] + 1` for all valid `j` that can reach `i`
3. Store that minimum value in `nums[i]`
4. Return `nums[n]` at the end

---

Let me break that down!

- `j` is the position/index you're currently at
- `nums[j]` is the maximum number of steps you can jump from position `j`
- `j + nums[j]` is the farthest position you can reach from position `j`

So if you're at position `j = 1` and `nums[1] = 3`, then you can jump anywhere
from position 1 to position 1+3 = 4.

The condition `j + nums[j] >= i` is asking: "Can position `j` reach position `i` or beyond?"

For example, if `j = 1`, `nums[1] = 3`, and `i = 3`, then:
- `j + nums[j] = 1 + 3 = 4`
- Since `4 >= 3`, position 1 can reach position 3